<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="d3.v3.js"></script>
</head>
<body>
<div id="main">
    <div id="explanation" style="visibility: hidden;">
        <span id="percentage"></span><br/>
        bugs contained.
    </div>
    <div id="sequence"></div>

    <div id="chart1"></div>
    <div id="chart2"></div>
</div>
<div id="bugCodeContainer" style="position: absolute; top: 10px; left: 800px; width: 400px; height: 1000px;">
    <p id="bugFile"></p>
    <pre class="prettyprint"><code id="bugCode" class="language-cpp"></code> </pre>
</div>


<script>
    /*
     *  Declarations of the common variable
     */

    var width = 800,
        height = 600,
        radius1 = 250;

    // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
    var tag = {
        w: 150, h: 30, s: 3, t: 10
    };

    var formatNumber = d3.format(",d");

    var x = d3.scale.linear()
        .range([0, 2 * Math.PI]);

    var y = d3.scale.sqrt()
        .range([0, radius1]);

    var color = d3.scale.category20();

    var partition = d3.layout.partition()
        .value(function (d) {
            return d.size;
        });

    var arc1 = d3.svg.arc()
        .startAngle(function (d) {
            return Math.max(0, Math.min(2 * Math.PI, x(d.x)));
        })
        .endAngle(function (d) {
            return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
        })
        .innerRadius(function (d) {
            return Math.max(0, y(d.y));
        })
        .outerRadius(function (d) {
            return Math.max(0, y(d.y + d.dy));
        });

    var svg1 = d3.select("#chart1").append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + (height / 2) + ")");

    var totalSize = 0; // Used for calculating percentage

    function displayCode(fileName) {
        var url = "data/" + fileName;
        var jsonFile = new XMLHttpRequest();
        jsonFile.open("GET", url, true);
        jsonFile.send();

        jsonFile.onreadystatechange = function () {
            if (jsonFile.readyState == 4 && jsonFile.status == 200) {
                console.log(jsonFile.responseText);
                document.getElementById("bugCode").innerHTML = jsonFile.responseText;
            }
        }
    }

    /*
     * Load the data
     */

    d3.json("data/bugdemo.json", function (error, root) {
        if (error) throw error;

        var path1 = svg1.selectAll(".path1")
            .data(partition.nodes(root))
            .enter().append("path")
            .attr("class", "path1")
            .attr("d", arc1)
            .style("fill", function (d) {
                return color(d.name);
            })
            .on("click", mouseClickSvg1)
            .on("mouseover", mouseOverSvg1)
            .append("title")
            .text(function (d) {
                return d.name + "\n" + formatNumber(d.value);
            });

        totalSize = path1.node().__data__.value;
        bugs = root.bugs;


        bugs.sort(function(a,b){
            if(a.typenum!=b.typenum){
                if(a.typenum>b.typenum)
                    return 1;
                if(a.typenum<b.typenum)
                    return -1;
                return 0;
            }
            if(a.severity>b.severity)
                return 1;
            if(a.severity<b.severity)
                return -1;
            return 0;
        });

        var path2 = svg1.selectAll(".path2")
            .data(pie2(bugs))
            .enter().append("path")
            .attr("class", "path2")
            .attr("fill", function (d, i) {
                return colorArr[d.data.typenum](linear2(d.data.severity));
            })
            .attr("d", arc2)
            .each(function (d) {
                this._current = d;
            }) // store the initial values
            .on("mouseover", function () {
                d3.select(this).attr("fill", d3.rgb(123, 126, 139));
            })
            .on("mouseout", function (d, i) {
                d3.select(this)
                    .transition()
                    .duration(250)
                    .attr("fill", colorArr[d.data.typenum](linear2(d.data.severity)));
            })
            .on("click", function (d, i) {
                alert("name: " + d.data.name + "\ntype: " + d.data.type + "\nseverity: " + d.data.severity);
            });

        console.log("size of total:", totalSize);
    });

    function mouseClickSvg1(d) {
        svg1.transition()
            .duration(1000) // set the transition time
            .tween("scale", function () {
                var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
                    yd = d3.interpolate(y.domain(), [d.y, 1]),
                    yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius1]);
                return function (t) {
                    x.domain(xd(t));
                    y.domain(yd(t)).range(yr(t));
                };
            })
            .selectAll(".path1")
            .attrTween("d", function (d) {
                return function () {
                    return arc1(d);
                };
            });
        console.log(d.name);
        console.log(d.bugs);
        change(d.bugs);

        fileName = d.bugs[0].location[0].filepath;
        d3.select("#bugFile").text(fileName);
        displayCode(fileName)
    }

    // Fade all but the current sequence, and show it in the path trail.
    function mouseOverSvg1(d) {

        var percentage = (100 * d.value / totalSize).toPrecision(3);
        var percentageString = percentage + "%";
        if (percentage < 0.1) {
            percentageString = "< 0.1%";
        }

        d3.select("#percentage").text(percentageString);

        d3.select("#explanation").style("visibility", "");

        var sequenceArray = getAncestors(d);
        updatePathDisplay(sequenceArray, percentageString);

        // Fade all the segments.
        svg1.selectAll(".path1").style("opacity", 0.1);

        // Then highlight only those that are an ancestor of the current segment.
        svg1.selectAll(".path1")
            .filter(function (node) {
                return (sequenceArray.indexOf(node) >= 0);
            })
            .style("opacity", 1);

        fileName = d.bugs[0].location[0].filepath;
        d3.select("#bugFile").text(fileName);
        displayCode(fileName)
    }

    // Restore everything to full opacity when moving off the visualization.
    function mouseLeaveSvg1(d) {

        // Hide the path trail
        d3.select("#trail").style("visibility", "hidden");

        // Deactivate all segments during transition.
        svg1.selectAll(".path1").on("mouseover", null);

        // Transition each segment to full opacity and then reactivate it.
        svg1.selectAll(".path1")
            .transition()
            .duration(1000)
            .style("opacity", 1)
            .each("end", function () {
                d3.select(this).on("mouseover", mouseOverSvg1);
            });

        d3.select("#explanation")
            .style("visibility", "hidden");
    }

    // Given a node in a partition layout, return an array of all of its ancestor
    // nodes, highest first, but excluding the root.
    function getAncestors(node) {
        var path = [];
        var current = node;
        while (current.parent) {
            path.unshift(current);
            current = current.parent;
        }
        return path;
    }

    function initializePathDisplay() {
        // Add the svg area.
        var trail = d3.select("#sequence").append("svg:svg")
            .attr("width", width)
            .attr("height", 50)
            .attr("id", "trail");
        // Add the label at the end, for the percentage.
        trail.append("svg:text")
            .attr("id", "endlabel")
            .style("fill", "#000");
    }

    // Generate a string that describes the points of a path.
    function genPathDisplayTag(d, i) {
        var points = [];
        points.push("0,0");
        points.push(tag.w + ",0");
        points.push(tag.w + tag.t + "," + (tag.h / 2));
        points.push(tag.w + "," + tag.h);
        points.push("0," + tag.h);
        if (i > 0) { // Leftmost path point; don't include 6th vertex.
            points.push(tag.t + "," + (tag.h / 2));
        }
        return points.join(" ");
    }

    // Update the path trail to show the current sequence and percentage.
    function updatePathDisplay(nodeArray, percentageString) {

        // Data join; key function combines name and depth (= position in sequence).
        var g = d3.select("#trail")
            .selectAll("g")
            .data(nodeArray, function (d) {
                return d.name + d.depth;
            });

        // Add path tag and label for entering nodes.
        var entering = g.enter().append("svg:g");

        entering.append("svg:polygon")
            .attr("points", genPathDisplayTag)
            .style("fill", function (d) {
                return "#bbbbbb";
            });

        entering.append("svg:text")
            .attr("x", (tag.w + tag.t) / 2)
            .attr("y", tag.h / 2)
            .attr("dy", "0.35em")
            .attr("text-anchor", "middle")
            .text(function (d) {
                return d.name;
            });

        // Set position for entering and updating nodes.
        g.attr("transform", function (d, i) {
            return "translate(" + i * (tag.w + tag.s) + ", 0)";
        });

        // Remove exiting nodes.
        g.exit().remove();

        // Now move and update the percentage at the end.
        d3.select("#trail").select("#endlabel")
            .attr("x", (nodeArray.length + 0.5) * (tag.w + tag.s))
            .attr("y", tag.h / 2)
            .attr("dy", "0.35em")
            .attr("text-anchor", "middle")
            .text(percentageString);

        // Make the trail visible, if it's hidden.
        d3.select("#trail")
            .style("visibility", "");

    }

    initializePathDisplay();
    d3.select("#chart1").on("mouseleave", mouseLeaveSvg1);


</script>
<script>
    //给定多个type，每个type对应一个标号，每一个标号对应一个颜色
    //每个type中不同的bug的severity可能不一样，severity通过颜色的深浅来表示

    var //width = 800,
        //height = 800,
        radius2 = 370;

    var enterAntiClockwise = {
        startAngle: Math.PI * 2,
        endAngle: Math.PI * 2
    };

    //var color = d3.scale.category20();
    var linear2 = d3.scale.linear().domain([1, 8]).range([0, 1]);
    var colorArr = new Array();
    colorArr[0] = d3.interpolate(d3.rgb(127, 255, 212), d3.rgb(203, 255, 237));//no use
    colorArr[1] = d3.interpolate(d3.rgb(26, 168, 191), d3.rgb(117, 202, 216));
    colorArr[2] = d3.interpolate(d3.rgb(255, 201, 102), d3.rgb(255, 222, 163));
    colorArr[3] = d3.interpolate(d3.rgb(100, 149, 237), d3.rgb(162, 191, 244));
    colorArr[4] = d3.interpolate(d3.rgb(253, 113, 113), d3.rgb(253, 169, 169));
    colorArr[5] = d3.interpolate(d3.rgb(127, 255, 212), d3.rgb(178, 255, 229));

    var pie2 = d3.layout.pie()
        .sort(null)
        .value(function (d) {
            return 1;
        });

    var arc2 = d3.svg.arc()
        .innerRadius(radius2 - 100)
        .outerRadius(radius2 - 70);
    /*
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    */

    d3.selectAll("input").on("change", change);

    /*
        var timeout = setTimeout(function() {
            d3.select("input[value=\"apples\"]").property("checked", true).each(change);
        }, 2000);
        */

    function change(bugdata) {
        //clearTimeout(timeout);
        /*
                if(this.value == "oranges"){
                    bugdata = bugs2;
                }else{
                    bugdata = bugs1;
                }
                */

        //   var bugdata = d;
        // alert(d.length);

        bugdata.sort(function(a,b){
            if(a.typenum!=b.typenum){
                if(a.typenum>b.typenum)
                    return 1;
                if(a.typenum<b.typenum)
                    return -1;
                return 0;
            }
            if(a.severity>b.severity)
                return 1;
            if(a.severity<b.severity)
                return -1;
            return 0;
        });
        var path2 = svg1.selectAll(".path2");
        path2 = path2.data(pie2(bugdata)); // update the data
        // set the start and end angles to Math.PI * 2 so we can transition
        // anticlockwise to the actual values later
        path2.enter().append("path")
            .attr("class", "path2")
            .attr("fill", function (d, i) {
                return colorArr[d.data.typenum](linear2(d.data.severity));
            })
            .attr("d", arc2(enterAntiClockwise))
            .each(function (d) {
                this._current = {
                    data: d.data,
                    value: d.value,
                    startAngle: enterAntiClockwise.startAngle,
                    endAngle: enterAntiClockwise.endAngle
                };
            })
            .on("mouseover", function () {
            d3.select(this).attr("fill", d3.rgb(123, 126, 139));
        })
            .on("mouseout", function (d, i) {
                d3.select(this)
                    .transition()
                    .duration(250)
                    .attr("fill", colorArr[d.data.typenum](linear2(d.data.severity)));
            })
            .on("click", function (d, i) {
                alert("name: " + d.data.name + "\ntype: " + d.data.type + "\nseverity: " + d.data.severity);
            });; // store the initial values

        path2.exit()
            .transition()
            .duration(750)
            .attrTween('d', arcTweenOut)
            .remove() // now remove the exiting arcs

        path2.transition().duration(750).attrTween("d", arcTween).attr("fill", function (d, i) {
            return colorArr[d.data.typenum](linear2(d.data.severity));
        });
        ; // redraw the arcs
    }

    // Store the displayed angles in _current.
    // Then, interpolate from _current to the new angles.
    // During the transition, _current is updated in-place by d3.interpolate.
    function arcTween(a) {
        var i = d3.interpolate(this._current, a);
        this._current = i(0);
        return function (t) {
            return arc2(i(t));
        };
    }

    // Interpolate exiting arcs start and end angles to Math.PI * 2
    // so that they 'exit' at the end of the data
    function arcTweenOut(a) {
        var i = d3.interpolate(this._current, {startAngle: Math.PI * 2, endAngle: Math.PI * 2, value: 0});
        this._current = i(0);
        return function (t) {
            return arc2(i(t));
        };
    }
</script>
